<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Library · TypeClasses.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://JuliaFunctional.github.io/TypeClasses.jl/library/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">TypeClasses.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/">Introduction</a></li><li><a class="tocitem" href="../manual-TypeClasses/">TypeClasses</a></li><li><a class="tocitem" href="../manual-DataTypes/">DataTypes</a></li></ul></li><li class="is-active"><a class="tocitem" href>Library</a><ul class="internal"><li><a class="tocitem" href="#Functor,-Applicative,-Monad"><span>Functor, Applicative, Monad</span></a></li><li><a class="tocitem" href="#Semigroup,-Monoid,-Alternative"><span>Semigroup, Monoid, Alternative</span></a></li><li><a class="tocitem" href="#FlipTypes"><span>FlipTypes</span></a></li><li><a class="tocitem" href="#TypeClasses.DataTypes"><span>TypeClasses.DataTypes</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Library</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Library</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/master/docs/src/library.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="TypeClasses-Public-API"><a class="docs-heading-anchor" href="#TypeClasses-Public-API">TypeClasses Public API</a><a id="TypeClasses-Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#TypeClasses-Public-API" title="Permalink"></a></h1><h2 id="Functor,-Applicative,-Monad"><a class="docs-heading-anchor" href="#Functor,-Applicative,-Monad">Functor, Applicative, Monad</a><a id="Functor,-Applicative,-Monad-1"></a><a class="docs-heading-anchor-permalink" href="#Functor,-Applicative,-Monad" title="Permalink"></a></h2><p>Foreach, using <code>Base.foreach</code></p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.@syntax_foreach" href="#TypeClasses.@syntax_foreach"><code>TypeClasses.@syntax_foreach</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@syntax_foreach begin
  # Vectors behaves like nested for loops within @syntax_foreach
  a = [1, 2, 3]
  b = [10, 20]
  @pure a + b
end
# [[11, 21], [12, 22], [13, 23]]</code></pre><p>This is a variant of the monadic syntax which uses <code>foreach</code> for both map<em>like and flatmap</em>like. See <code>Monadic.@monadic</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L17-L28">source</a></section></article><p>Functor, using <code>Base.map</code></p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.@syntax_map" href="#TypeClasses.@syntax_map"><code>TypeClasses.@syntax_map</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@syntax_map begin
  # Vectors behave similar to nested for loops within @syntax_map
  a = [1, 2, 3]
  b = [10, 20]
  @pure a + b
end
# [[11, 21], [12, 22], [13, 23]]</code></pre><p>This is a variant of the monadic syntax which uses <code>map</code> for both map<em>like and flatmap</em>like. See <code>Monadic.@monadic</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L51-L62">source</a></section></article><p>Applicative Core</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.pure" href="#TypeClasses.pure"><code>TypeClasses.pure</code></a> — <span class="docstring-category">Function</span></header><section><div><p>pure(T::Type, a)</p><p>wraps value a into container T</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.ap" href="#TypeClasses.ap"><code>TypeClasses.ap</code></a> — <span class="docstring-category">Function</span></header><section><div><p>ap(f::F1, a::F2) -&gt; F3</p><p>Apply function in container <code>F1</code> to element in container <code>F2</code>, returning results in the same container <code>F3</code>. The default implementation uses <code>flatmap</code> and <code>map</code>, so that in general only those two need to be defined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L83-L88">source</a></section></article><p>Applicative Helper</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.mapn" href="#TypeClasses.mapn"><code>TypeClasses.mapn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mapn(f, a1::F{T1}, a2::F{T2}, a3::F{T3}, ...) -&gt; F{T}</code></pre><p>Apply a function over applicative contexts instead of plain values. Similar to <code>Base.map</code>, however sometimes the semantic differs slightly. <code>TypeClasses.mapn</code> always follows the semantics of <code>TypeClasses.flatmap</code> if defined.</p><p>E.g. for <code>Base.Vector</code> the <code>Base.map</code> function zips the inputs and checks for same length. On the other hand <code>TypeClasses.mapn</code> combines all combinations of inputs  instead of the zip (which conforms with the semantics of flattening nested Vectors).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L135-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.@mapn" href="#TypeClasses.@mapn"><code>TypeClasses.@mapn</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@mapn f(a, b, c, d)</code></pre><p>translates to</p><pre><code class="nohighlight hljs">mapn(f, a, b, c, d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L97-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.tupled" href="#TypeClasses.tupled"><code>TypeClasses.tupled</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">tupled(Option(1), Option(2), Option(3)) == Option((1,2,3))
tupled(Option(1), None, Option(3)) == None</code></pre><p>Combine several Applicative contexts by building up a Tuple</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L193-L198">source</a></section></article><p>Monad Core</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.flatmap" href="#TypeClasses.flatmap"><code>TypeClasses.flatmap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flatmap(function_returning_A, a::A)::A</code></pre><p><code>flatmap</code> applies a function to a container and immediately flattens it out. While map would give you <code>A{A{...}}</code>, flatmap gives you a plain <code>A{...}</code>, without any nesting.</p><p>If you define your own versions of flatmap, the recommendation is to apply a <code>Base.convert</code> after applying <code>f</code>. This makes sure your flatmap is typesafe, and actually enables sound interactions with other types which may be convertable to your A.</p><p>E.g. for Vector the implementation looks as follows:</p><pre><code class="nohighlight hljs">TypeClasses.flatmap(f, v::Vector) = vcat((convert(Vector, f(x)) for x in v)...)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L250-L264">source</a></section></article><p>Monad Helper</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.flatten" href="#TypeClasses.flatten"><code>TypeClasses.flatten</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flatten(::A{A})::A = flatmap(identity, a)</code></pre><p><code>flatten</code> gets rid of one level of nesting. Has a default fallback to use <code>flatmap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L271-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.:↠" href="#TypeClasses.:↠"><code>TypeClasses.:↠</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">a ↠ b = flatmap(_ -&gt; b, a) # \twoheadrightarrow</code></pre><p>A convenience operator for monads which just applies the second monad within the first one.</p><p>The operator ↠ (\twoheadrightarrow) is choosen because the other favourite ≫ (\gg) which would have been in accordance  with <a href="https://hackage.haskell.org/package/base-unicode-symbols-0.2.4.2/docs/Control-Monad-Unicode.html">haskell unicode syntax for monads</a> is unfortunately parsed as boolean comparison with extra semantics which leads to errors with non-boolean applications.</p><p>↠ is just the most similar looking other operator which does not have this restriction and is right-associative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L279-L290">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.@syntax_flatmap" href="#TypeClasses.@syntax_flatmap"><code>TypeClasses.@syntax_flatmap</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@syntax_flatmap begin
  # Vector behave similar to nested for loops within @syntax_flatmap
  a = [1, 2, 3]
  b = [10, 20]
  @pure a + b
end
# [11, 21, 12, 22, 13, 23]</code></pre><p>This is the standard monadic syntax which uses <code>map</code> for map<em>like and <code>flatmap</code> for flatmap</em>like. See <code>Monadic.@monadic</code> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FunctorApplicativeMonad.jl#L296-L307">source</a></section></article><h2 id="Semigroup,-Monoid,-Alternative"><a class="docs-heading-anchor" href="#Semigroup,-Monoid,-Alternative">Semigroup, Monoid, Alternative</a><a id="Semigroup,-Monoid,-Alternative-1"></a><a class="docs-heading-anchor-permalink" href="#Semigroup,-Monoid,-Alternative" title="Permalink"></a></h2><p>Semigroup</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.combine" href="#TypeClasses.combine"><code>TypeClasses.combine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine(::T, ::T)::T  # overload this
⊕(::T, ::T)::T  # alias \oplus
combine(a, b, c, d, ...)  # using combine(a, b) internally</code></pre><p>Associcative combinator operator.</p><p>The symbol <code>⊕</code> (\oplus) following http://hackage.haskell.org/package/base-unicode-symbols-0.2.3/docs/Data-Monoid-Unicode.html</p><p><strong>Following Laws should hold</strong></p><p>Associativity</p><pre><code class="nohighlight hljs">⊕(::T, ⊕(::T, ::T)) == ⊕(⊕(::T, ::T), ::T)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/MonoidAlternative.jl#L37-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.:⊕" href="#TypeClasses.:⊕"><code>TypeClasses.:⊕</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">combine(::T, ::T)::T  # overload this
⊕(::T, ::T)::T  # alias \oplus
combine(a, b, c, d, ...)  # using combine(a, b) internally</code></pre><p>Associcative combinator operator.</p><p>The symbol <code>⊕</code> (\oplus) following http://hackage.haskell.org/package/base-unicode-symbols-0.2.3/docs/Data-Monoid-Unicode.html</p><p><strong>Following Laws should hold</strong></p><p>Associativity</p><pre><code class="nohighlight hljs">⊕(::T, ⊕(::T, ::T)) == ⊕(⊕(::T, ::T), ::T)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/MonoidAlternative.jl#L37-L51">source</a></section><section><div><pre><code class="language-julia-repl hljs">julia&gt; using TypeClasses, Dictionaries

julia&gt; dict1 = Dictionary([:a, :b, :c], [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])
3-element Dictionaries.Dictionary{Symbol, String}
 :a │ &quot;1&quot;
 :b │ &quot;2&quot;
 :c │ &quot;3&quot;

julia&gt; dict2 = Dictionary([:b, :c, :d], [&quot;4&quot;, &quot;5&quot;, &quot;6&quot;])
3-element Dictionaries.Dictionary{Symbol, String}
 :b │ &quot;4&quot;
 :c │ &quot;5&quot;
 :d │ &quot;6&quot;

julia&gt; dict1 ⊕ dict2
4-element Dictionaries.Dictionary{Symbol, String}
 :a │ &quot;1&quot;
 :b │ &quot;24&quot;
 :c │ &quot;35&quot;
 :d │ &quot;6&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeInstances/AbstractDictionary.jl#L9-L32">source</a></section></article><p>Neutral</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.neutral" href="#TypeClasses.neutral"><code>TypeClasses.neutral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">neutral
neutral(::Type)
neutral(_default_return_value) = neutral</code></pre><p>Neutral element for <code>⊕</code>, also called &quot;identity element&quot;. <code>neutral</code> is a function which can give you  the neutral element for a concrete type, or alternatively you can use it as a singleton value which combines with everything.</p><p>By default <code>neutral(type)</code> will return the generic <code>neutral</code> singleton. You can override it for your specific type to have a more specific neutral value.</p><p>We decided for name <code>neutral</code> according to https://en.wikipedia.org/wiki/Identity_element. Alternatives seem inappropriate</p><ul><li>&quot;identity&quot; is already taken</li><li>&quot;identity_element&quot; seems to long</li><li>&quot;I&quot; is too ambiguous</li><li>&quot;unit&quot; seems ambiguous with physical units</li></ul><p><strong>Following Laws should hold</strong></p><p>Left Identity</p><pre><code class="nohighlight hljs">  ⊕(neutral(T), t::T) == t</code></pre><p>Right Identity</p><pre><code class="nohighlight hljs">  ⊕(t::T, neutral(T)) == t</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/MonoidAlternative.jl#L4-L31">source</a></section></article><p>Monoid Helpers</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.reduce_monoid" href="#TypeClasses.reduce_monoid"><code>TypeClasses.reduce_monoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">reduce_monoid(itr; init=TypeClasses.neutral)</code></pre><p>Combines all elements of <code>itr</code> using the initial element <code>init</code> if given and <code>TypeClasses.combine</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/MonoidAlternative.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.foldr_monoid" href="#TypeClasses.foldr_monoid"><code>TypeClasses.foldr_monoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">foldr_monoid(itr; init=TypeClasses.neutral)</code></pre><p>Combines all elements of <code>itr</code> using the initial element <code>init</code> if given and <code>TypeClasses.combine</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/MonoidAlternative.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.foldl_monoid" href="#TypeClasses.foldl_monoid"><code>TypeClasses.foldl_monoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">foldl_monoid(itr; init=TypeClasses.neutral)</code></pre><p>Combines all elements of <code>itr</code> using the initial element <code>init</code> if given and <code>TypeClasses.combine</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/MonoidAlternative.jl#L69-L73">source</a></section></article><p>Alternative</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.orelse" href="#TypeClasses.orelse"><code>TypeClasses.orelse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orelse(a, b)  # overload this
⊘(a, b)  # alias \oslash
orelse(a, b, c, d, ...)  # using orelse(a, b) internally</code></pre><p>Implements an alternative logic, like having two options a and b, taking the first valid one. We decided for &quot;orelse&quot; instead of &quot;alternatives&quot; to highlight the intrinsic asymmetry in choosing.</p><p>The operator ⊘ (\oslash) is choosen to have an infix operator which is similar to \oplus, however clearly distinguishable, asymmetric, and somehow capturing a choice semantics. The slash actually is used to indicate choice (at least in some languages, like German), and luckily \oslash exists (and is not called \odiv).  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/MonoidAlternative.jl#L95-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.:⊘" href="#TypeClasses.:⊘"><code>TypeClasses.:⊘</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">orelse(a, b)  # overload this
⊘(a, b)  # alias \oslash
orelse(a, b, c, d, ...)  # using orelse(a, b) internally</code></pre><p>Implements an alternative logic, like having two options a and b, taking the first valid one. We decided for &quot;orelse&quot; instead of &quot;alternatives&quot; to highlight the intrinsic asymmetry in choosing.</p><p>The operator ⊘ (\oslash) is choosen to have an infix operator which is similar to \oplus, however clearly distinguishable, asymmetric, and somehow capturing a choice semantics. The slash actually is used to indicate choice (at least in some languages, like German), and luckily \oslash exists (and is not called \odiv).  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/MonoidAlternative.jl#L95-L105">source</a></section><section><div><pre><code class="nohighlight hljs">orelse(d1::Dict, d2::Dict) -&gt; Dict</code></pre><p>Following the orelse semantics on Option values, the first value is retained, and the second is dropped. Hence this is the flipped version of <code>Base.merge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeInstances/Dict.jl#L29-L34">source</a></section><section><div><pre><code class="nohighlight hljs">orelse(future1, future2, ...)
future1 ⊘ future2</code></pre><p>Runs both in parallel and collects which ever result is first. Then interrupts all other futures and returns the found result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeInstances/Future.jl#L11-L16">source</a></section><section><div><pre><code class="nohighlight hljs">orelse(task1, task2, ...)
task1 ⊘ task2</code></pre><p>Runs both in parallel and collects which ever result is first. Then interrupts all other tasks and returns the found result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeInstances/Task.jl#L8-L13">source</a></section><section><div><pre><code class="nohighlight hljs">orelse(d1::Dict, d2::Dict) -&gt; Dict</code></pre><p>Following the orelse semantics on Option values, the first value is retained, and the second is dropped. Hence this is the flipped version of <code>Base.merge</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeInstances/AbstractDictionary.jl#L48-L53">source</a></section></article><h2 id="FlipTypes"><a class="docs-heading-anchor" href="#FlipTypes">FlipTypes</a><a id="FlipTypes-1"></a><a class="docs-heading-anchor-permalink" href="#FlipTypes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.flip_types" href="#TypeClasses.flip_types"><code>TypeClasses.flip_types</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">flip_types(value::T{S{A}})::S{T{A}}</code></pre><p>reverses the two outer containers, e.g. making an Array of Options into an Option of an Array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FlipTypes.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.default_flip_types_having_pure_combine_apEltype" href="#TypeClasses.default_flip_types_having_pure_combine_apEltype"><code>TypeClasses.default_flip_types_having_pure_combine_apEltype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">default_flip_types_having_pure_combine_apEltype(container)</code></pre><p>Use this helper function to ease the definition of <code>flip_types</code> for your own type.</p><p>Note that the following interfaces are assumed:</p><ul><li>iterable</li><li>pure</li><li>combine</li><li>ap on eltype</li></ul><p>And in case of empty iterable in addition the following:</p><ul><li>neutral</li><li>pure on eltype</li></ul><p>We do not overload <code>flip_types</code> directly because this would require dispatching on whether <code>isAp(eltype(T))</code>. But relying on <code>eltype</code> to define different semantics is strongly discouraged.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/TypeClasses/FlipTypes.jl#L11-L28">source</a></section></article><h2 id="TypeClasses.DataTypes"><a class="docs-heading-anchor" href="#TypeClasses.DataTypes">TypeClasses.DataTypes</a><a id="TypeClasses.DataTypes-1"></a><a class="docs-heading-anchor-permalink" href="#TypeClasses.DataTypes" title="Permalink"></a></h2><p>Iterable</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.DataTypes.Iterables.Iterable" href="#TypeClasses.DataTypes.Iterables.Iterable"><code>TypeClasses.DataTypes.Iterables.Iterable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>wrapper to clearly indicate that something should be treated as an Iterable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/DataTypes/Iterables.jl#L13-L15">source</a></section></article><p>Callable</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.DataTypes.Callable" href="#TypeClasses.DataTypes.Callable"><code>TypeClasses.DataTypes.Callable</code></a> — <span class="docstring-category">Type</span></header><section><div><p>wrapper to clearly indicate that something should be treated as a Callable</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/DataTypes/Callable.jl#L1-L3">source</a></section></article><p>Writer</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.DataTypes.Writers.Writer" href="#TypeClasses.DataTypes.Writers.Writer"><code>TypeClasses.DataTypes.Writers.Writer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>like Pair, however assumes that <code>combine</code> is defined for the accumulator <code>acc</code></p><p>Note that <code>neutral</code> may indeed be undefined</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/DataTypes/Writers.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.DataTypes.Writers.getaccumulator" href="#TypeClasses.DataTypes.Writers.getaccumulator"><code>TypeClasses.DataTypes.Writers.getaccumulator</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">getaccumulator(writer::Writer)</code></pre><p>Returns the accumulator of the Writer value.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TypeClasses

julia&gt; getaccumulator(Writer(&quot;example-accumulator&quot;))
&quot;example-accumulator&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/DataTypes/Writers.jl#L23-L38">source</a></section></article><p>State</p><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.DataTypes.States.State" href="#TypeClasses.DataTypes.States.State"><code>TypeClasses.DataTypes.States.State</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">State(func)

State() do state
  ....
  return value, newstate
end</code></pre><p>State monad, which capsulate a state within a monadic type for monadic encapsulation of the state-handling.</p><p>You can run a state by either calling it, or by using <code>Base.run</code>. If no initial state is given, <code>nothing</code> is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/DataTypes/States.jl#L4-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.DataTypes.States.getstate" href="#TypeClasses.DataTypes.States.getstate"><code>TypeClasses.DataTypes.States.getstate</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">getstate</code></pre><p>Standard value for returning the hidden state of the <code>State</code> Monad.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TypeClasses

julia&gt; mystate = @syntax_flatmap begin
         state = getstate
         @pure println(&quot;state = $state&quot;)
       end;

julia&gt; mystate(42)
state = 42
(nothing, 42)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/DataTypes/States.jl#L28-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TypeClasses.DataTypes.States.putstate" href="#TypeClasses.DataTypes.States.putstate"><code>TypeClasses.DataTypes.States.putstate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">putstate(x)</code></pre><p><code>putstate</code> is a standard constructor for <code>State</code> objects which changes the underlying state to the given value. </p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using TypeClasses

julia&gt; mystate = @syntax_flatmap begin
         putstate(10)
         state = getstate
         @pure println(&quot;The state is $state, and should be 10&quot;)
       end;

julia&gt; mystate()
The state is 10, and should be 10
(nothing, 10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaFunctional/TypeClasses.jl/blob/c5f21d9637a451db6f8fe73d9aaca49f2faf1b50/src/DataTypes/States.jl#L53-L75">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../manual-DataTypes/">« DataTypes</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.4 on <span class="colophon-date" title="Saturday 24 July 2021 22:25">Saturday 24 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
