var documenterSearchIndex = {"docs":
[{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"CurrentModule = TypeClasses\nDocTestSetup  = quote\n    using TypeClasses\n    using Dictionaries\nend","category":"page"},{"location":"manual-TypeClasses/#TypeClasses","page":"TypeClasses","title":"TypeClasses","text":"","category":"section"},{"location":"manual-TypeClasses/#functor_applicative_monad","page":"TypeClasses","title":"Functor, Applicative, Monad","text":"","category":"section"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"Typeclass Interface Helpers from TypeClasses\n&nbsp; TypeClasses.foreach = Base.foreach @syntax_foreach\nFunctor, Applicative, Monad TypeClasses.map = Base.map @syntax_map\nApplicative, Monad TypeClasses.pure, TypeClasses.ap ap is automatically defined if you defined Base.map and TypeClasses.flatmap. Further helpers: mapn, @mapn, tupled, neutral_applicative, combine_applicative, orelse_applicative\nMonad TypeClasses.flatmap flatten, ↠ (\\twoheadrightarrow), @syntax_flatmap","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"There are three syntax supported, where @syntax_flatmap is the most useful, however sometimes @syntax_foreach may also be handy because of its power and simplicity in a programming language with side-effects (like Julia).","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"julia> @syntax_foreach begin  # translates to foreach calls\n         a = [1, 2]\n         b = [3, 4]\n         @pure println(\"a = $a, b = $b\")\n       end\na = 1, b = 3\na = 1, b = 4\na = 2, b = 3\na = 2, b = 4\n\njulia> @syntax_map begin  # translates to map calls\n         a = [1, 2]\n         b = [3, 4]\n         @pure \"a = $a, b = $b\"\n       end\n2-element Vector{Vector{String}}:\n [\"a = 1, b = 3\", \"a = 1, b = 4\"]\n [\"a = 2, b = 3\", \"a = 2, b = 4\"]\n\njulia> @syntax_flatmap begin  # translates to map/flatmap calls\n         a = [1, 2]\n         b = [3, 4]\n         @pure \"a = $a, b = $b\"\n       end\n4-element Vector{String}:\n \"a = 1, b = 3\"\n \"a = 1, b = 4\"\n \"a = 2, b = 3\"\n \"a = 2, b = 4\"","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"For Applicatives there are a couple of additional helpers","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"julia> f(a, b, c) = a + b + c\nf (generic function with 1 method)\n\njulia> @mapn f([1,2], [10], [100, 200])  # can also be written as `mapn(f, [1,2], [10], [100,200])`\n4-element Vector{Int64}:\n 111\n 211\n 112\n 212\n\njulia> tupled([1,2], [3, 4])\n4-element Vector{Tuple{Int64, Int64}}:\n (1, 3)\n (1, 4)\n (2, 3)\n (2, 4)","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"And for Monads you have","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"julia> flatten([[1,2], [3,4]])\n4-element Vector{Int64}:\n 1\n 2\n 3\n 4\n\njulia> [1, 2] ↠ [3, 4]  # flatmap(_ -> [3,4], [1,2])\n4-element Vector{Int64}:\n 3\n 4\n 3\n 4\n\njulia> Option(3) ↠ Option() ↠ Option(\"hi\")  # stopping behaviour with operator syntax\nConst(nothing)","category":"page"},{"location":"manual-TypeClasses/#Considerations","page":"TypeClasses","title":"Considerations","text":"","category":"section"},{"location":"manual-TypeClasses/#Functor-map","page":"TypeClasses","title":"Functor - map","text":"","category":"section"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"You can overload TypeClasses.map or Base.map, as you like, they are both the very same.","category":"page"},{"location":"manual-TypeClasses/#Monad-flatmap","page":"TypeClasses","title":"Monad - flatmap","text":"","category":"section"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"We decided to use flatmap as the interface, because it is often more intuitiv to implement than flatten and also comes quite natural next to map.","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"In order to enable simple interactions between monads, all flatmap implementations use convert before flattening. The exception is Identity which for convenience just returns whatever inner monad may appear, without forcing a conversion to Identity. For example, this enables you to combine Vector with OPtion, Try, Either in all ways.","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"@syntax_flatmap provides monadic syntax (similar to haskell do-notation). However, the macro translates to flatmap and map only, and does not need pure.","category":"page"},{"location":"manual-TypeClasses/#Applicative-ap-/-mapn-/-map","page":"TypeClasses","title":"Applicative - ap / mapn / map","text":"","category":"section"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"mapn is explicitly an extra function, because it has a generic definition which uses pure and ap, which can also be derived given the implementation of flatmap and single map. Many types define Base.map(f, a, b, c, ...) which is in this sense a mapn. However, they sometimes do not conform to the respective implementation of flatten/flatmap. For example Vector defines Base.map(f, a, b, c, ...) for Vectors of equal length, however flattening vectors is collecting all combinations of all vectors. These are two different semantics and it is hard to forsee which error-potentials this would bring if they are intermixed. Another example is Dictionaries.Dictionary, which supports map similar to Vector, checking for same indices first and raising an error otherwise.","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"For convenience, Base.map(f, a, b, c...) is defined as an alias for TypeClasses.mapn(f, a, b, c...) for the data types Option, Try, Either, ContextManager, Callable, Writer, and State.","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"Each Applicative can lift an underlying Monoid. In addition some Applicatives also define Monoids themselves (e.g. Vector). Hence, we distinguish both by adding functions neutral_applicative, combine_applicative, orelse_applicative.","category":"page"},{"location":"manual-TypeClasses/#semigroup_monoid_alternative","page":"TypeClasses","title":"Semigroup, Monoid, Alternative","text":"","category":"section"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"Typeclass Interface Helpers from TypeClasses\nMonoid, Alternative TypeClasses.neutral \nMonoid, Semigroup TypeClasses.combine alias ⊕ (\\oplus), reduce_monoid, foldr_monoid, foldl_monoid\nAlternative TypeClasses.orelse alias ⊘ (\\oslash)","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"A Semigroup just supports combine, a Monoid in addition supports neutral.","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"Sometimes, the type itself has an obvious way of combining multiple values, like for String or Vector. Other times, the combine is forwarded to inner elements in case it is needed.","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"julia> neutral(Vector) ⊕ [1,2] ⊕ [3]\n3-element Vector{Any}:\n 1\n 2\n 3\n\njulia> d = Dict(:a => \"hello.\", :b => 4) ⊕ Dict(:a => \"world.\", :c => 1.0)\nDict{Symbol, Any} with 3 entries:\n  :a => \"hello.world.\"\n  :b => 4\n  :c => 1.0\n\njulia> combine(Option(), Option([1]), Option([2, 3]))\nIdentity([1, 2, 3])","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"Let's look at Alternative. Take the Dict as an example of a container. If we find the same key in both dictionaries, combine is going to recursively call combine on them. Alternatively, we could just grab the one or the other. This is implemented within the orelse function, which will always take the first value it finds. ","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"julia> Dict(:a => \"first\", :b => 4) ⊘ Dict(:a => true, :c => 1.0)\nDict{Symbol, Any} with 3 entries:\n  :a => \"first\"\n  :b => 4\n  :c => 1.0\n\njulia> orelse(Option(), Option(1), Option(4))\nIdentity(1)","category":"page"},{"location":"manual-TypeClasses/#Considerations-2","page":"TypeClasses","title":"Considerations","text":"","category":"section"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"We decided to use the same neutral for both Monoid and Alternative because of simplicity. ","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"Julia does not have stable typeparameters (for optimization a typeparameter may be inferred as Any instead of more concrete type), and hence Alternative (which is concept targeted at Functors, i.e. things with one typeparameter) becomes way more similar to Monoid.","category":"page"},{"location":"manual-TypeClasses/#flip_types","page":"TypeClasses","title":"FlipTypes","text":"","category":"section"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"Typeclass Interface Helpers from TypeClasses\nFlipTypes TypeClasses.flip_types TypeClasses.default_flip_types_having_pure_combine_apEltype","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"flip_types(::A{B{C}}) should return ::B{A{C}}. Hence the name: it flips the first two types. ","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"Here are some examples","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"julia> flip_types([Option(:a), Option(:b)])\nIdentity([:a, :b])\n\njulia> flip_types(Identity([:a, :b]))\n2-element Vector{Identity{Symbol}}:\n Identity(:a)\n Identity(:b)\n\njulia> flip_types([Option(:a), Option()])\nConst(nothing)\n\njulia> using Dictionaries\n\njulia> flip_types(dictionary((:a => [1,2], :b => [3, 4])))\n4-element Vector{Dictionary{Symbol, Int64}}:\n {:a = 1, :b = 3}\n {:a = 1, :b = 4}\n {:a = 2, :b = 3}\n {:a = 2, :b = 4}\n\njulia> flip_types([dictionary((:a => 1, :b => 2)), dictionary((:a => 10, :b => 20)), dictionary((:b => 200, :c => 300))])\n1-element Dictionaries.Dictionary{Symbol, Vector{Int64}}\n :b │ [2, 20, 200]","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"You see that fliptypes may actually forget information. This is normal, but very important to remember. Hence, applying fliptypes twice usually not return to the original value, but will change the result.","category":"page"},{"location":"manual-TypeClasses/#Considerations-3","page":"TypeClasses","title":"Considerations","text":"","category":"section"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"FlipTypes is not an official TypeClass, however proofs to be a very essential abstraction. Normally this comes with the TypeClass Traversable and is called sequence, however that name is not very self-explanatory and sounds quite specific.","category":"page"},{"location":"manual-TypeClasses/","page":"TypeClasses","title":"TypeClasses","text":"TypeClasses.flip_types has already one big usage in ExtensibleEffects.jl, for a generic implementation of effect handling.","category":"page"},{"location":"library/#TypeClasses-Public-API","page":"Library","title":"TypeClasses Public API","text":"","category":"section"},{"location":"library/#Functor,-Applicative,-Monad","page":"Library","title":"Functor, Applicative, Monad","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = TypeClasses","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Foreach, using Base.foreach","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@syntax_foreach","category":"page"},{"location":"library/#TypeClasses.@syntax_foreach","page":"Library","title":"TypeClasses.@syntax_foreach","text":"@syntax_foreach begin\n  # Vectors behaves like nested for loops within @syntax_foreach\n  a = [1, 2, 3]\n  b = [10, 20]\n  @pure a + b\nend\n# [[11, 21], [12, 22], [13, 23]]\n\nThis is a variant of the monadic syntax which uses foreach for both maplike and flatmaplike. See Monadic.@monadic for more details.\n\n\n\n\n\n","category":"macro"},{"location":"library/","page":"Library","title":"Library","text":"Functor, using Base.map","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"@syntax_map","category":"page"},{"location":"library/#TypeClasses.@syntax_map","page":"Library","title":"TypeClasses.@syntax_map","text":"@syntax_map begin\n  # Vectors behave similar to nested for loops within @syntax_map\n  a = [1, 2, 3]\n  b = [10, 20]\n  @pure a + b\nend\n# [[11, 21], [12, 22], [13, 23]]\n\nThis is a variant of the monadic syntax which uses map for both maplike and flatmaplike. See Monadic.@monadic for more details.\n\n\n\n\n\n","category":"macro"},{"location":"library/","page":"Library","title":"Library","text":"Applicative Core","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"pure\nap","category":"page"},{"location":"library/#TypeClasses.pure","page":"Library","title":"TypeClasses.pure","text":"pure(T::Type, a)\n\nwraps value a into container T\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.ap","page":"Library","title":"TypeClasses.ap","text":"ap(f::F1, a::F2) -> F3\n\nApply function in container F1 to element in container F2, returning results in the same container F3. The default implementation uses flatmap and map, so that in general only those two need to be defined.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Applicative Helper","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"mapn\n@mapn\ntupled","category":"page"},{"location":"library/#TypeClasses.mapn","page":"Library","title":"TypeClasses.mapn","text":"mapn(f, a1::F{T1}, a2::F{T2}, a3::F{T3}, ...) -> F{T}\n\nApply a function over applicative contexts instead of plain values. Similar to Base.map, however sometimes the semantic differs slightly. TypeClasses.mapn always follows the semantics of TypeClasses.flatmap if defined.\n\nE.g. for Base.Vector the Base.map function zips the inputs and checks for same length. On the other hand TypeClasses.mapn combines all combinations of inputs  instead of the zip (which conforms with the semantics of flattening nested Vectors).\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.@mapn","page":"Library","title":"TypeClasses.@mapn","text":"@mapn f(a, b, c, d)\n\ntranslates to\n\nmapn(f, a, b, c, d)\n\n\n\n\n\n","category":"macro"},{"location":"library/#TypeClasses.tupled","page":"Library","title":"TypeClasses.tupled","text":"tupled(Option(1), Option(2), Option(3)) == Option((1,2,3))\ntupled(Option(1), None, Option(3)) == None\n\nCombine several Applicative contexts by building up a Tuple\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Monad Core","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"flatmap","category":"page"},{"location":"library/#TypeClasses.flatmap","page":"Library","title":"TypeClasses.flatmap","text":"flatmap(function_returning_A, a::A)::A\n\nflatmap applies a function to a container and immediately flattens it out. While map would give you A{A{...}}, flatmap gives you a plain A{...}, without any nesting.\n\nIf you define your own versions of flatmap, the recommendation is to apply a Base.convert after applying f. This makes sure your flatmap is typesafe, and actually enables sound interactions with other types which may be convertable to your A.\n\nE.g. for Vector the implementation looks as follows:\n\nTypeClasses.flatmap(f, v::Vector) = vcat((convert(Vector, f(x)) for x in v)...)\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Monad Helper","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"flatten\n↠\n@syntax_flatmap","category":"page"},{"location":"library/#TypeClasses.flatten","page":"Library","title":"TypeClasses.flatten","text":"flatten(::A{A})::A = flatmap(identity, a)\n\nflatten gets rid of one level of nesting. Has a default fallback to use flatmap.\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.:↠","page":"Library","title":"TypeClasses.:↠","text":"a ↠ b = flatmap(_ -> b, a) # \\twoheadrightarrow\n\nA convenience operator for monads which just applies the second monad within the first one.\n\nThe operator ↠ (\\twoheadrightarrow) is choosen because the other favourite ≫ (\\gg) which would have been in accordance  with haskell unicode syntax for monads is unfortunately parsed as boolean comparison with extra semantics which leads to errors with non-boolean applications.\n\n↠ is just the most similar looking other operator which does not have this restriction and is right-associative.\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.@syntax_flatmap","page":"Library","title":"TypeClasses.@syntax_flatmap","text":"@syntax_flatmap begin\n  # Vector behave similar to nested for loops within @syntax_flatmap\n  a = [1, 2, 3]\n  b = [10, 20]\n  @pure a + b\nend\n# [11, 21, 12, 22, 13, 23]\n\nThis is the standard monadic syntax which uses map for maplike and flatmap for flatmaplike. See Monadic.@monadic for more details.\n\n\n\n\n\n","category":"macro"},{"location":"library/#Semigroup,-Monoid,-Alternative","page":"Library","title":"Semigroup, Monoid, Alternative","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Semigroup","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"combine\n⊕","category":"page"},{"location":"library/#TypeClasses.combine","page":"Library","title":"TypeClasses.combine","text":"combine(::T, ::T)::T  # overload this\n⊕(::T, ::T)::T  # alias \\oplus\ncombine(a, b, c, d, ...)  # using combine(a, b) internally\n\nAssocicative combinator operator.\n\nThe symbol ⊕ (\\oplus) following http://hackage.haskell.org/package/base-unicode-symbols-0.2.3/docs/Data-Monoid-Unicode.html\n\nFollowing Laws should hold\n\nAssociativity\n\n⊕(::T, ⊕(::T, ::T)) == ⊕(⊕(::T, ::T), ::T)\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.:⊕","page":"Library","title":"TypeClasses.:⊕","text":"combine(::T, ::T)::T  # overload this\n⊕(::T, ::T)::T  # alias \\oplus\ncombine(a, b, c, d, ...)  # using combine(a, b) internally\n\nAssocicative combinator operator.\n\nThe symbol ⊕ (\\oplus) following http://hackage.haskell.org/package/base-unicode-symbols-0.2.3/docs/Data-Monoid-Unicode.html\n\nFollowing Laws should hold\n\nAssociativity\n\n⊕(::T, ⊕(::T, ::T)) == ⊕(⊕(::T, ::T), ::T)\n\n\n\n\n\njulia> using TypeClasses, Dictionaries\n\njulia> dict1 = Dictionary([:a, :b, :c], [\"1\", \"2\", \"3\"])\n3-element Dictionaries.Dictionary{Symbol, String}\n :a │ \"1\"\n :b │ \"2\"\n :c │ \"3\"\n\njulia> dict2 = Dictionary([:b, :c, :d], [\"4\", \"5\", \"6\"])\n3-element Dictionaries.Dictionary{Symbol, String}\n :b │ \"4\"\n :c │ \"5\"\n :d │ \"6\"\n\njulia> dict1 ⊕ dict2\n4-element Dictionaries.Dictionary{Symbol, String}\n :a │ \"1\"\n :b │ \"24\"\n :c │ \"35\"\n :d │ \"6\"\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Neutral","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"neutral","category":"page"},{"location":"library/#TypeClasses.neutral","page":"Library","title":"TypeClasses.neutral","text":"neutral(::Type{T})::T\n\nNeutral element for ⊕, also called \"identity element\".\n\nWe decided for name neutral according to https://en.wikipedia.org/wiki/Identity_element. Alternatives seem inappropriate\n\n\"identity\" is already taken\n\"identity_element\" seems to long\n\"I\" is too ambiguous\n\"unit\" seems ambiguous with physical units\n\nFollowing Laws should hold\n\nLeft Identity\n\n  ⊕(neutral(T), t::T) == t\n\nRight Identity\n\n  ⊕(t::T, neutral(T)) == t\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Monoid Helpers","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"reduce_monoid\nfoldr_monoid\nfoldl_monoid","category":"page"},{"location":"library/#TypeClasses.reduce_monoid","page":"Library","title":"TypeClasses.reduce_monoid","text":"reduce_monoid(itr; [init])\nreduce_monoid(monoid_combine_function, itr; [init])\n\nCombines all elements of itr using the initial element init if given and combine. If no init is given, neutral and combine is used instead.\n\nIf monoid_combine_function is given, it neutral(monoid_combine_function) is expected to return the corresponding neutral function\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.foldr_monoid","page":"Library","title":"TypeClasses.foldr_monoid","text":"foldr_monoid(itr; [init])\nfoldr_monoid(monoid_combine_function, itr; [init])\n\nCombines all elements of itr using the initial element init if given and combine. If no init is given, neutral and combine is used instead.\n\nIf monoid_combine_function is given, it neutral(monoid_combine_function) is expected to return the corresponding neutral function\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.foldl_monoid","page":"Library","title":"TypeClasses.foldl_monoid","text":"foldl_monoid(itr; [init])\nfoldl_monoid(monoid_combine_function, itr; [init])\n\nCombines all elements of itr using the initial element init if given and combine. If no init is given, neutral and combine is used instead.\n\nIf monoid_combine_function is given, it neutral(monoid_combine_function) is expected to return the corresponding neutral function\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"Alternative","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"orelse\n⊘","category":"page"},{"location":"library/#TypeClasses.orelse","page":"Library","title":"TypeClasses.orelse","text":"orelse(a, b)  # overload this\n⊘(a, b)  # alias \\oslash\norelse(a, b, c, d, ...)  # using orelse(a, b) internally\n\nImplements an alternative logic, like having two options a and b, taking the first valid one. We decided for \"orelse\" instead of \"alternatives\" to highlight the intrinsic asymmetry in choosing.\n\nThe operator ⊘ (\\oslash) is choosen to have an infix operator which is similar to \\oplus, however clearly distinguishable, asymmetric, and somehow capturing a choice semantics. The slash actually is used to indicate choice (at least in some languages, like German), and luckily \\oslash exists (and is not called \\odiv).  \n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.:⊘","page":"Library","title":"TypeClasses.:⊘","text":"orelse(a, b)  # overload this\n⊘(a, b)  # alias \\oslash\norelse(a, b, c, d, ...)  # using orelse(a, b) internally\n\nImplements an alternative logic, like having two options a and b, taking the first valid one. We decided for \"orelse\" instead of \"alternatives\" to highlight the intrinsic asymmetry in choosing.\n\nThe operator ⊘ (\\oslash) is choosen to have an infix operator which is similar to \\oplus, however clearly distinguishable, asymmetric, and somehow capturing a choice semantics. The slash actually is used to indicate choice (at least in some languages, like German), and luckily \\oslash exists (and is not called \\odiv).  \n\n\n\n\n\norelse(d1::Dict, d2::Dict) -> Dict\n\nFollowing the orelse semantics on Option values, the first value is retained, and the second is dropped. Hence this is the flipped version of Base.merge.\n\n\n\n\n\norelse(future1, future2, ...)\nfuture1 ⊘ future2\n\nRuns both in parallel and collects which ever result is first. Then interrupts all other futures and returns the found result.\n\n\n\n\n\norelse(task1, task2, ...)\ntask1 ⊘ task2\n\nRuns both in parallel and collects which ever result is first. Then interrupts all other tasks and returns the found result.\n\n\n\n\n\norelse(d1::Dict, d2::Dict) -> Dict\n\nFollowing the orelse semantics on Option values, the first value is retained, and the second is dropped. Hence this is the flipped version of Base.merge.\n\n\n\n\n\n","category":"function"},{"location":"library/#FlipTypes","page":"Library","title":"FlipTypes","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"flip_types\ndefault_flip_types_having_pure_combine_apEltype","category":"page"},{"location":"library/#TypeClasses.flip_types","page":"Library","title":"TypeClasses.flip_types","text":"flip_types(value::T{S{A}})::S{T{A}}\n\nreverses the two outer containers, e.g. making an Array of Options into an Option of an Array.\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.default_flip_types_having_pure_combine_apEltype","page":"Library","title":"TypeClasses.default_flip_types_having_pure_combine_apEltype","text":"default_flip_types_having_pure_combine_apEltype(container)\n\nUse this helper function to ease the definition of flip_types for your own type.\n\nNote that the following interfaces are assumed:\n\niterable\npure\ncombine\nap on eltype\n\nAnd in case of empty iterable in addition the following:\n\nneutral\npure on eltype\n\nWe do not overload flip_types directly because this would require dispatching on whether isAp(eltype(T)). But relying on eltype to define different semantics is strongly discouraged.\n\n\n\n\n\n","category":"function"},{"location":"library/#TypeClasses.DataTypes","page":"Library","title":"TypeClasses.DataTypes","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Iterable","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Iterable","category":"page"},{"location":"library/#TypeClasses.DataTypes.Iterables.Iterable","page":"Library","title":"TypeClasses.DataTypes.Iterables.Iterable","text":"wrapper to clearly indicate that something should be treated as an Iterable\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Callable","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Callable","category":"page"},{"location":"library/#TypeClasses.DataTypes.Callable","page":"Library","title":"TypeClasses.DataTypes.Callable","text":"wrapper to clearly indicate that something should be treated as a Callable\n\n\n\n\n\n","category":"type"},{"location":"library/","page":"Library","title":"Library","text":"Writer","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"Writer\ngetaccumulator","category":"page"},{"location":"library/#TypeClasses.DataTypes.Writers.Writer","page":"Library","title":"TypeClasses.DataTypes.Writers.Writer","text":"like Pair, however assumes that combine is defined for the accumulator acc\n\nNote that neutral may indeed be undefined\n\n\n\n\n\n","category":"type"},{"location":"library/#TypeClasses.DataTypes.Writers.getaccumulator","page":"Library","title":"TypeClasses.DataTypes.Writers.getaccumulator","text":"getaccumulator(writer::Writer)\n\nReturns the accumulator of the Writer value.\n\nExamples\n\njulia> using TypeClasses\n\njulia> getaccumulator(Writer(\"example-accumulator\"))\n\"example-accumulator\"\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"State","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"State\ngetstate\nputstate","category":"page"},{"location":"library/#TypeClasses.DataTypes.States.State","page":"Library","title":"TypeClasses.DataTypes.States.State","text":"State(func)\n\nState() do state\n  ....\n  return value, newstate\nend\n\nState monad, which capsulate a state within a monadic type for monadic encapsulation of the state-handling.\n\nYou can run a state by either calling it, or by using Base.run. If no initial state is given, nothing is used.\n\n\n\n\n\n","category":"type"},{"location":"library/#TypeClasses.DataTypes.States.getstate","page":"Library","title":"TypeClasses.DataTypes.States.getstate","text":"getstate\n\nStandard value for returning the hidden state of the State Monad.\n\nExamples\n\njulia> using TypeClasses\n\njulia> mystate = @syntax_flatmap begin\n         state = getstate\n         @pure println(\"state = $state\")\n       end;\n\njulia> mystate(42)\nstate = 42\n(nothing, 42)\n\n\n\n\n\n","category":"constant"},{"location":"library/#TypeClasses.DataTypes.States.putstate","page":"Library","title":"TypeClasses.DataTypes.States.putstate","text":"putstate(x)\n\nputstate is a standard constructor for State objects which changes the underlying state to the given value. \n\nExamples\n\njulia> using TypeClasses\n\njulia> mystate = @syntax_flatmap begin\n         putstate(10)\n         state = getstate\n         @pure println(\"The state is $state, and should be 10\")\n       end;\n\njulia> mystate()\nThe state is 10, and should be 10\n(nothing, 10)\n\n\n\n\n\n","category":"function"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"CurrentModule = TypeClasses\nDocTestSetup  = quote\n    using TypeClasses\n    using Dictionaries\nend","category":"page"},{"location":"manual/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"Welcome to TypeClasses.jl. TypeClasses defines general programmatic abstractions taken from Scala cats and Haskell TypeClasses.","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"We use \"interface\" and \"typeclass\" synonymously. The following interfaces are defined:","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"TypeClass Methods Description\nFunctor  Base.map The basic definition of a container or computational context.\nApplicative Functor & TypeClasses.pure & TypeClasses.ap (automatically defined when map and flatmap are defined) Computational context with support for parallel execution.\nMonad Applicative & TypeClasses.flatmap Computational context with support for sequential, nested execution.\nSemigroup TypeClasses.combine, alias ⊕ The notion of something which can be combined with other things of its kind.\nMonoid Semigroup & TypeClasses.neutral A semigroup with a neutral element is called a Monoid, an often used category.\nAlternative TypeClasses.neutral & TypeClasses.orelse, alias ⊘ Slightly different than Monoid, the orelse semantic does not merge two values, but just takes one of the two.\nFlipTypes TypeClasses.flip_types Enables dealing with nested types. Transforms an A{B{C}} into an B{A{C}}.","category":"page"},{"location":"manual/#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"TypeClasses\")","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"Use it like","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"using TypeClasses","category":"page"},{"location":"manual/#More-Details","page":"Introduction","title":"More Details","text":"","category":"section"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"For detailed information of the TypeClasses, see TypeClasses.","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"For detailed information about implementations of the TypeClasses for concrete DataTypes, see DataTypes.","category":"page"},{"location":"manual/#General-Design-Decisions","page":"Introduction","title":"General Design Decisions","text":"","category":"section"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"reuse as much Base as possible\nmake it stable (hence so far we only support the most important type-classes)\nmake it simple\nmake it convenient\nbring examples","category":"page"},{"location":"manual/#No-dispatch-on-eltype","page":"Introduction","title":"No dispatch on eltype","text":"","category":"section"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"With Functors and the like a typical thing you want to do is to get to know more about the inner type, i.e. the eltype. It turns out this is unwanted.","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"Julia's type-inference is seriously incomplete and there is also no sign that this will ever change. The compiler tries very hard to always infer the maximal specific type, but may fallback to more generic types if unsure or because of time-constraints. A calculation which may build up a Vector{Number} may easily turn out as a Vector{Any}, and even for a method returning Vector{String}, the underlying code may be that dynamic in nature, that the compiler just cannot infer the type and will return Vector{Any}. The take home message here is that, practically, eltype is an instable function. It's concrete behaviour, somewhere within a nested stack of function calls, may change between versions, depending on changing undocumented compiler-heuristics, or may even change because another layer of abstractions is added somewhere within the nested calls, which again triggers different compiler-heuristics.","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"If you dispatch on Vector{Number} in order to implement something specific for Number, that may fail to catch the Vector{Number} which was interpreted as Vector{Any} because of approximate type inference. You need to make sure that the semantics of the method for Vector{Any} is actually identical to the specialised version Vector{Number}. You should only ever do performance optimisations when dispatching on eltype, never base your semantics on eltype.","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"With Functors, specifically with Monads, we have exactly the setting where we may dispatch on eltype to define different semantics. They key reason is that there are a couple of Monads where you cannot inspect the concrete elements, for instance Callable where the element is hidden behind an arbitrary function. Hence you may not be able to implement a function for Callable{Any} in a sensible way, while it actually is well-defined for Callable{Callable}. That is not Julia.","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"Another example is the typeclass neutral. It turns out you can define neutral for each Applicative which ElementType itself implements neutral. It is really tempting to define the generic implementation for Applicatives, dispatching on eltype... Instead we provide specific applicative versions neutral_applicative and combine_applicative which assume the elements comply to the Neutral and Semigroup interface respectively. Similar for orelse.","category":"page"},{"location":"manual/","page":"Introduction","title":"Introduction","text":"As we cannot safely dispatch on eltype, the Julia way is to just assume your ElementType has the characteristics needed for your function, i.e. use duck-typing instead of dispatch. Naturally, this will work for all containers with the right elements. And in case the elements do not implement the required interfaces, it will fail with a well self-explaining MethodError. This you can then debug which will bring you directly to the place where you can inspect the elements in detail.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"CurrentModule = TypeClasses\nDocTestSetup  = quote\n    using TypeClasses\n    using Dictionaries\nend","category":"page"},{"location":"manual-DataTypes/#DataTypes","page":"DataTypes","title":"DataTypes","text":"","category":"section"},{"location":"manual-DataTypes/#Option,-Try,-Either","page":"DataTypes","title":"Option, Try, Either","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Option, Try, and Either are re-exported from DataTypesBasic.jl and equipped with the TypeClasses. As all three are implemented using the same primitives Identity and Const, they can actually be combined seamlessly. Option and Try are really only more specific Either. This is quite a unique design among typeclasses, which enables a lot flexibility and simplicity.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"DataType Implementation Helpers\nIdentity Identity isidentity, all&nbsp;TypeClasses\nConst Const Base.isconst, almost all TypeClasses, but without pure\nEither Either{L, R} = Union{Const{L}, Identity{R}} Either, Base.eltype, either, @either, flip_left_right, iseither, isleft, isright, getleft, getright, getleftOption, getrightOption, getOption, all&nbsp;TypeClasses\nTry Try{T} = Union{Const{<:Exception}, Identity{T}} Try, @Try, @TryCatch, istry, issuccess, isfailure, all&nbsp;TypeClasses\nOption Option{T} = Union{Const{Nothing}, Identity{T}} Option, isoption, issome, isnone, iffalse, iftrue, all&nbsp;TypeClasses","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"For more Details take also a look at DataTypesBasic.jl.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"If all works, the result is an Identity","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> @syntax_flatmap begin\n         a = true ? Option(4) : Option()\n         b = @Try isodd(a) ? error(\"stop\") : 5\n         c = either(:left, isodd(b), \"right\")\n         @pure a, b, c\n       end\nIdentity((4, 5, \"right\"))","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"If something fails, the computation stops early on, returning a Const","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> @syntax_flatmap begin\n         a = false ? Option(4) : Option()\n         b = @Try isodd(a) ? error(\"stop\") : 5\n         c = either(:left, isodd(b), \"right\")\n         @pure a, b, c\n       end\nConst(nothing)\n\njulia> @syntax_flatmap begin\n         a = true ? Option(5) : Option()\n         b = @Try isodd(a) ? error(\"stop\") : 5\n         c = either(:left, isodd(b), \"right\")\n         @pure a, b, c\n       end\nConst(Thrown(ErrorException(\"stop\")))\n\njulia> @syntax_flatmap begin\n         a = true ? Option(4) : Option()\n         b = @Try isodd(a) ? error(\"stop\") : 6\n         c = either(:left, isodd(b), \"right\")\n         @pure a, b, c\n       end\nConst(:left)","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can also combine Option, Try, Either. When combining Const with Const or Identity with Identity, the combine function of the underlying value is used. When combining Const with Identity, the Identity is always returned. When using Option, the value Option() = Const(nothing) deals as the neutral value and hence you can make any Semigroup (something which supports combine) into a Monoid (something which supports combine and neutral) by just wrapping it into Option.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> combine(Option(), Option(4))\nIdentity(4)\n\njulia> @Try(4) ⊕ @Try(error(\"stop\"))  # \\oplus is an alias for `combine`\nIdentity(4)\n\njulia> either(:left, true, \"right.\") ⊕ @Try(\"success.\") ⊕ Option(\"also needs to be a string.\")\nIdentity(\"right.success.also needs to be a string.\")","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"If your the element does not support combine, you can still use orelse (alias ⊘, \\oslash), which will just return the first Identity value.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> either(:left, false, \"right.\") ⊘ @Try(\"success.\") ⊘ Option([\"does\" \"not\" \"need\" \"to\" \"be\" \"a\" \"string.\"])\nIdentity(\"success.\")","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"For completenes, the Monad definition of Option, Try, and Either also come with the binary operator ↠ (\\twoheadrightarrow), which acts somehow as the reverse of orelse: It will stop at the first Const value:","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> either(:left, true, \"right.\") ↠ @Try(error(\"stop.\")) ↠ Option([\"does\" \"not\" \"need\" \"to\" \"be\" \"a\" \"string.\"])\nConst(Thrown(ErrorException(\"stop.\")))","category":"page"},{"location":"manual-DataTypes/#FlipTypes","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"With any Functor you can flip types.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> flip_types(Const(Identity(3)))\nIdentity(Const(3))\n\njulia> flip_types(Identity(Const(3)))\nConst(3)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You may be surprised by Const(3), however this is correct. Flipping an outer Identity will map Identity over the inner Functor. The Const Functor, however, just ignores everything when mapped over it and will stay the same. More correctly, it would have changed its pseudo return value, however this is not represented in Julia, leaving it literally constant. ","category":"page"},{"location":"manual-DataTypes/#ContextManager","page":"DataTypes","title":"ContextManager","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"ContextManager also comes from DataTypesBasic.jl. It is super handy to define your own enter-exit semantics.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-2","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> create_context(x) = @ContextManager continuation -> begin\n         println(\"before x = $x\")\n         result = continuation(x)\n         println(\"after x = $x\")\n         result\n       end\ncreate_context (generic function with 1 method)\n\njulia> context = @syntax_flatmap begin\n         a = create_context(3)\n         b = create_context(a*a)\n         @pure a, b\n       end;\n\njulia> context() do x\n         println(\"within x = $x\")\n         x\n       end\nbefore x = 3\nbefore x = 9\nwithin x = (3, 9)\nafter x = 9\nafter x = 3\n(3, 9)","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-2","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"ContextManager only supports Functor/Applicative/Monad TypeClasses.","category":"page"},{"location":"manual-DataTypes/#FlipTypes-2","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"ContextManager only supports Functor/Applicative/Monad TypeClasses.","category":"page"},{"location":"manual-DataTypes/#AbstractVector","page":"DataTypes","title":"AbstractVector","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Base.Vector are supported. More concretely, methods are implemented for the whole AbstractArray tree, by converting from Vector. Vector types can be seamlessly combined with Either (including Options and Try), providing a very flexible setup out-of-the-box. Either types get converted to singleton lists in the case of Identity or an empty list in the case of Const.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-3","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"The implementation of TypeClasses.flatmap follows the flattening/combining semantics, which takes all combinations of the vectors. As if you would have used for loops, however with constructing a result by collecting everything.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> @syntax_flatmap begin\n         a = [1, 2]\n         b = [:x, :y]\n         @pure a, b\n         end\n4-element Vector{Tuple{Int64, Symbol}}:\n (1, :x)\n (1, :y)\n (2, :x)\n (2, :y)\n\njulia> @syntax_flatmap begin\n         a = [1, 2, 3, 4, 5]\n         @pure b = a + 1\n         c = iftrue(a % 2 == 0) do\n           a + b\n         end\n         @Try @assert a > 3\n         @pure @show a, b, c\n       end\n(a, b, c) = (4, 5, 9)\n1-element Vector{Any}:\n (4, 5, 9)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Sometimes it may also be handy to use the pure function.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> pure(Vector, 1)\n1-element Vector{Int64}:\n 1","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-3","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Vectors only support Monoid interface, no Alternative.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> neutral(Vector)\nAny[]\n\njulia> [1] ⊕ [5,6]\n3-element Vector{Int64}:\n 1\n 5\n 6\n\njulia> combine([1], [5, 6])\n3-element Vector{Int64}:\n 1\n 5\n 6\n\njulia> foldl_monoid([[1,2], [4,5], [10]])\n5-element Vector{Int64}:\n  1\n  2\n  4\n  5\n 10","category":"page"},{"location":"manual-DataTypes/#FlipTypes-3","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can flip nested types with Vector. It assumes the inner type supports Applicative method ap (if you have defined flatmap the ap method is automatically defined for you).","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> flip_types([Option(1), Option(\"2\"), Option(:three)])\nIdentity(Any[1, \"2\", :three])\n\njulia> flip_types([Option(1), Option(), Option(:three)])\nConst(nothing)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Remember that flip_types usually forgets information, like here in the case when a Const is found.","category":"page"},{"location":"manual-DataTypes/#Dict","page":"DataTypes","title":"Dict","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"We do not support AbstractDict in general, because there is no common way of constructing such dicts. For the concrete Base.Dict we know how to construct it.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-4","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Base.map explicitly throws an error on Dict, so there is no way to support Functor/Applicative/Monad typeclasses.","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-4","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"neutral for Dict just returns a general empty Dict","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> neutral(Dict)\nDict{Any, Any}() ","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"combine (⊕) will forward the function call combine to its elements. orelse (⊘) will take the first existing value, i.e. a flipped version of merge.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> d1 = Dict(:a => \"3\", :b => \"1\")\nDict{Symbol, String} with 2 entries:\n  :a => \"3\"\n  :b => \"1\"\n\njulia> d2 = Dict(:a => \"5\", :b => \"9\", :c => \"15\")\nDict{Symbol, String} with 3 entries:\n  :a => \"5\"\n  :b => \"9\"\n  :c => \"15\"\n\njulia> d1 ⊕ d2\nDict{Symbol, String} with 3 entries:\n  :a => \"35\"\n  :b => \"19\"\n  :c => \"15\"\n\njulia> d1 ⊘ d2\nDict{Symbol, String} with 3 entries:\n  :a => \"3\"\n  :b => \"1\"\n  :c => \"15\"","category":"page"},{"location":"manual-DataTypes/#FlipTypes-4","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"flip_types works only in one direction.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> flip_types(Dict(:a => [1,2], :b => [3, 4])) \n4-element Vector{Dict{Symbol, Int64}}:\n Dict(:a => 1, :b => 3)\n Dict(:a => 1, :b => 4)\n Dict(:a => 2, :b => 3)\n Dict(:a => 2, :b => 4)\n\njulia> flip_types([Dict(:a => 1, :b => 3), Dict(:a => 2, :b => 4)])\nERROR: map is not defined on dictionaries","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"As you see, this is becaue Base.map explicitly throws an Error for Base.Dict.","category":"page"},{"location":"manual-DataTypes/#AbstractDictionary","page":"DataTypes","title":"AbstractDictionary","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Luckily this limitation of Base.Dict can be circumvented by using the package Dictionaries which enhances the dictionary interface and speeds up its performance.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-5","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"AbstractDictionary is the abstract type provided by the package, and it already defines Base.map for it, so that we can implement Functor/Applicative/Monad interfaces on top. The semantics of the flattening of dictionaries follows the implementation in Scala Cats for Scala's Map type. It works like first filtering for common keys and then doing stuff respectively.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> using Dictionaries\n\njulia> dict = Dictionary([\"a\", \"b\", \"c\"], [1, 2, 3])\n3-element Dictionaries.Dictionary{String, Int64}\n \"a\" │ 1\n \"b\" │ 2\n \"c\" │ 3\n\njulia> create_dictionary(x) = Dictionary([\"b\", \"c\", \"d\"], [10x, 20x, 30x])\ncreate_dictionary (generic function with 1 method)\n\njulia> @syntax_flatmap begin\n         a = dict\n         b = create_dictionary(a)\n         @pure a, b\n         end\n2-element Dictionaries.Dictionary{String, Tuple{Int64, Int64}}\n \"b\" │ (2, 20)\n \"c\" │ (3, 60)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"20 is 10 times 2, and 60 is 20 times 3. You see it picks the right values for \"b\" and \"c\" respectively. The key \"d\" does not exist in all dictionaries and hence is filtered out.","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-5","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"The implementation for neutral, combine and orelse are analogous to those for Dict, just a bit more abstract. Thanks to the good interfaces defined in the package Dictionaries, we can support general AbstractDictionary.","category":"page"},{"location":"manual-DataTypes/#FlipTypes-5","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"flip_types now actually works in both directions, as AbstractDictionary is a Monad itself.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> flip_types(dictionary((:a => [1,2], :b => [3, 4]))) \n4-element Vector{Dictionary{Symbol, Int64}}:\n {:a = 1, :b = 3}\n {:a = 1, :b = 4}\n {:a = 2, :b = 3}\n {:a = 2, :b = 4}\n\njulia> flip_types([\n           dictionary((:a => 1, :b => 2)),\n           dictionary((:a => 10, :b => 20)),\n           dictionary((:b => 200, :c => 300))\n       ])\n1-element Dictionaries.Dictionary{Symbol, Vector{Int64}}\n :b │ [2, 20, 200]","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"In the last example you can again recognize the filtering logic. Here it leaves :b as the only valid key.","category":"page"},{"location":"manual-DataTypes/#Iterable","page":"DataTypes","title":"Iterable","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"TypeClasses exports a wrapper type called Iterable which can be used to enable support on any iterable. ","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-6","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> collect(@syntax_flatmap begin\n         a = Iterable(1:2)\n         b = Iterable([3,6])\n         @pure a, b\n       end)\n4-element Vector{Tuple{Int64, Int64}}:\n (1, 3)\n (1, 6)\n (2, 3)\n (2, 6)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"The @syntax_flatmap macro actually can receive a wrapper function as an additional first argument with which the above can be written as","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> collect(@syntax_flatmap Iterable begin\n         a = 1:2\n         b = [3,6]\n         @pure a, b\n       end)\n4-element Vector{Tuple{Int64, Int64}}:\n (1, 3)\n (1, 6)\n (2, 3)\n (2, 6)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can use TypeClasses.pure to construct singleton Iterables","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> pure(Iterable, 1)\nIterable{TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}}(TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}(1))","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"It wraps an internal type which really just supports the singleton Iterable for your convenience.","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-6","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Iterable defines only the Monoid interface, just like Vector, but lazy.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> Iterable(1:2) ⊕ Iterable(5:6)\nIterable{Base.Iterators.Flatten{Tuple{UnitRange{Int64}, UnitRange{Int64}}}}(Base.Iterators.Flatten{Tuple{UnitRange{Int64}, UnitRange{Int64}}}((1:2, 5:6)))\n\njulia> collect(Iterable(1:2) ⊕ Iterable(5:6))\n4-element Vector{Int64}:\n 1\n 2\n 5\n 6","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"For implementing the neutral function, an extra type for an empty iterator was defined within TypeClasses. It is itself not exported, because using neutral instead is simpler and better.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> neutral(Iterable)\nIterable{TypeClasses.DataTypes.Iterables.IterateEmpty{Union{}}}(TypeClasses.DataTypes.Iterables.IterateEmpty{Union{}}())\n\njulia> collect(neutral(Iterable))\nUnion{}[]","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"The element-type is Union{} to be easily type-joined with other iterables and element-types.","category":"page"},{"location":"manual-DataTypes/#FlipTypes-6","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Again similar to Vector, Iterables define flip_types in a lazy style.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> it = Iterable(Option(i) for i ∈ [1, 4, 7])\nIterable{Base.Generator{Vector{Int64}, Type{Option{T} where T}}}(Base.Generator{Vector{Int64}, Type{Option{T} where T}}(Option{T} where T, [1, 4, 7]))\n\njulia> flip_types(it)\nIdentity(Iterable{Base.Iterators.Flatten{Tuple{Base.Iterators.Flatten{Tuple{TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}, TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}}}, TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}}}}(Base.Iterators.Flatten{Tuple{Base.Iterators.Flatten{Tuple{TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}, TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}}}, TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}}}((Base.Iterators.Flatten{Tuple{TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}, TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}}}((TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}(1), TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}(4))), TypeClasses.DataTypes.Iterables.IterateSingleton{Int64}(7)))))\n\njulia> map(collect, flip_types(it))\nIdentity([1, 4, 7])","category":"page"},{"location":"manual-DataTypes/#Callable","page":"DataTypes","title":"Callable","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"We also provide a wrapper for functions. To enable support for your functions, just wrap them into Callable.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-7","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"The callable monad is also sometimes called reader monad, however in Julia context that name doesn't make much sense. At least you heard it and can connect the concepts.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> func = @syntax_flatmap begin\n         a = Callable(x -> x * 10)\n         b = Callable(x -> x * 100 )\n         Callable() do x\n           x + a + b\n         end\n       end;\n\njulia> func(2)\n222","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Similar as for Iterables, it may simplify your setup to add Callable as a wrapper-function to @syntax_flatmap","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> func = @syntax_flatmap Callable begin\n         # you need to use anonymous functions, as the equal sign `=` is rewritten by the macro\n         a = x -> x * 10\n         b = x -> x * 100\n         identity() do x\n           x + a + b\n         end\n       end;\n\njulia> func(3)\n333","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can also wrap a value into Callable using pure. It works like a constant function.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> pure(Callable, 1)()\n1\n\njulia> pure(Callable, 1)(\"any\", :arguments, key=4)\n1","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-7","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Callables implement only combine by forwarding it to its elements.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> a = Callable(x -> \"hello $x\");\n\njulia> b = Callable(x -> \"!\");\n\njulia> (a ⊕ b)(:Albert)\n\"hello Albert!\"","category":"page"},{"location":"manual-DataTypes/#FlipTypes-7","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Callable itself does not implement flip_types as it would need to know its arguments in advance, which of course is impossible. However because it implements Monad interface, we can use it as a nested type within another type and get it out.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> a = Callable.([x -> x, y -> 2y, z -> z*z]);\n\njulia> flip_types(a)(3)\n3-element Vector{Int64}:\n 3\n 6\n 9","category":"page"},{"location":"manual-DataTypes/#@spawnat-and-@async","page":"DataTypes","title":"@spawnat and @async","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"@async runs the computation in another thread, @spawnat runs it on another machine potentially. Both are supported by TypeClasses.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"@async are described by Task objects, @spawnat by Distributed.Future respectively. Both kinds of contexts can be evaluated/run with Base.fetch.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-8","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> wait_a_little(f::Function, seconds=0.3) = @async begin\n         sleep(seconds)\n         f()\n       end\nwait_a_little (generic function with 2 methods)\n\njulia> wait_a_little(x, seconds=0.3) = wait_a_little(() -> x, seconds)\nwait_a_little (generic function with 4 methods)\n\njulia> squared = map(wait_a_little(4)) do x\n         x*x\n       end;  # returns a Task\n\njulia> fetch(squared)\n16\n\njulia> fetch(mapn(+, wait_a_little(11), wait_a_little(12)))\n23\n\njulia> monadic = @syntax_flatmap begin\n         a = wait_a_little(5)\n         b = wait_a_little(a + 3)\n         @pure a, b\n       end;  # returns a Task\n\njulia> fetch(monadic)\n(5, 8)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can do the very same using @spawnat, i.e. the type Distributed.Future. Just use the following function instead.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"using Distributed\n\nwait_a_little(f::Function, seconds=0.3) = @spawnat :any begin\n  sleep(seconds)\n  f()\nend","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can put any value into a Task and Future object by using TypeClasses.pure. You get it out again with Base.fetch.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> fetch(pure(Task, 4))\n4\n\njulia> using Distributed\n\njulia> fetch(pure(Future, \"a\"))\n\"a\"","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-8","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Future and Task do not implement neutral.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"combine is forwarded to the computation results.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> fetch(wait_a_little(\"hello.\") ⊕ wait_a_little(\"world.\"))\n\"hello.world.\"","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"orelse is defined as the Alternative semantics of running multiple threads in parallel and taking the faster one.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> fetch(wait_a_little(:a, 1.0) ⊘ wait_a_little(:b, 2.0))\n:a\n\njulia> fetch(wait_a_little(:a, 3.0) ⊘ wait_a_little(:b, 2.0))\n:b\n\njulia> fetch(wait_a_little(() -> error(\"fails\"), 0.1) ⊘ wait_a_little(:succeeds, 0.3))\n:succeeds\n\njulia> fetch(wait_a_little(:succeeds, 0.3) ⊘ wait_a_little(() -> error(\"fails\"), 0.1))\n:succeeds","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"In case all different paths fail, all errors are collected into an MultipleExceptions object","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> fetch(wait_a_little(() -> error(\"fails1\")) ⊘ wait_a_little(() -> error(\"fails2\")) ⊘ wait_a_little(() -> error(\"fails3\")) ⊘ wait_a_little(() -> error(\"fails4\")))\nERROR: TaskFailedException\nStacktrace:\n [1] wait\n   @ ./task.jl:322 [inlined]\n [2] fetch(t::Task)\n   @ Base ./task.jl:337\n [3] top-level scope\n   @ REPL[56]:1\n\n    nested task error: MultipleExceptions{NTuple{4, Thrown{TaskFailedException}}}((Thrown(TaskFailedException(Task (failed) @0x00007f5c8633af50)), Thrown(TaskFailedException(Task (failed) @0x00007f5c8633b0a0)), Thrown(TaskFailedException(Task (failed) @0x00007f5c864382b0)), Thrown(TaskFailedException(Task (failed) @0x00007f5c86438550))))","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can do the very same using @spawnat, i.e. the type Distributed.Future. Just use the following function instead.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"using Distributed\n\nwait_a_little(f::Function, seconds=0.3) = @spawnat :any begin\n  sleep(seconds)\n  f()\nend","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Note that a fetch on a Future will RETURN an RemoteException object instead of throwing an error.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> fetch(wait_a_little(() -> error(\"fails1\")) ⊘ wait_a_little(() -> error(\"fails2\")) ⊘ wait_a_little(() -> error(\"fails3\")) ⊘ wait_a_little(() -> error(\"fails4\")))\nRemoteException(1, CapturedException(MultipleExceptions{NTuple{4, RemoteException}}((RemoteException(1, CapturedException(ErrorException(\"fails1\"), [...]","category":"page"},{"location":"manual-DataTypes/#FlipTypes-8","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Implementing flip_types does not make much sense for Task and Future, as this would need to execute the Task, and map over its returned value, finally creating a bunch of dummy Tasks within it. @async and @spawnat are really meant to be lazy constructions.","category":"page"},{"location":"manual-DataTypes/#Writer","page":"DataTypes","title":"Writer","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"The Writer{Accumulator, Value} monad stores logs or other intermediate outputs. It is like Base.Pair{Accumulator, Value}, with the added assumption that Accumulator implements the TypeClasses.combine. Also the eltype of a Writer corresponds to the element-type of the Value.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-9","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can use the writer to implicitly accumulate any Semigroup or Monoid","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> @syntax_flatmap begin\n         a = pure(Writer{String}, 5)\n         Writer(\"first.\")\n         b = Writer(\"second.\", a*a)\n         @pure a, b\n       end\nWriter{String, Tuple{Int64, Int64}}(\"first.second.\", (5, 25))","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"In case you only have a Semigroup, just wrap it into Option, the default TypeClasses.pure implementation for writer will use Option() internally.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> @syntax_flatmap begin\n         a = pure(Writer, 5)\n         Writer(Option(\"hi\"))\n         @pure a\n       end\nWriter{Identity{String}, Int64}(Identity(\"hi\"), 5)","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-9","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"neutral and combine will foward the call to neutral and combine onto the element-types (for neutral) or the concrete element-values (for combine).","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> neutral(Writer{Option, Vector})\nConst(nothing) => Any[]\n\njulia> Writer(\"one.\", [1,2]) ⊕ Writer(\"two.\", [3,4]) ⊕ Writer(\"three.\", [5])\nWriter{String, Vector{Int64}}(\"one.two.three.\", [1, 2, 3, 4, 5])\n\njulia> Writer(\"hello.\") ⊕ Writer(\"world.\")  # the single argument constructor is just for logging, however as `nothing` always combines, this works too\nWriter{String, Nothing}(\"hello.world.\", nothing)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"We don't implement orelse, as it is commonly meant on container level, but there is no obvious failure semantics here.","category":"page"},{"location":"manual-DataTypes/#FlipTypes-9","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Writer supports flip_types by duplicating the accumulator respectively. ","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> flip_types(Writer(\"accumulator\", [1, 2, 3]))\n3-element Vector{Writer{String, Int64}}:\n Writer{String, Int64}(\"accumulator\", 1)\n Writer{String, Int64}(\"accumulator\", 2)\n Writer{String, Int64}(\"accumulator\", 3)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Used within another FlipTypes, Writer just accumulates the accumulator.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> flip_types([ Writer(\"one.\", 1), Writer(\"two.\", 2), Writer(\"three.\", 3) ])\nWriter{String, Vector{Int64}}(\"one.two.three.\", [1, 2, 3])","category":"page"},{"location":"manual-DataTypes/#Pair/Tuple","page":"DataTypes","title":"Pair/Tuple","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"Pair and Tuple have no Monad instances, but we support combine and neutral by forwarding the calls to its elements","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-10","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"No implementation. Please see Writer instead.","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-10","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> (\"hello.\" => [1,2]) ⊕ (\"world.\" => [3])\n\"hello.world.\" => [1, 2, 3]\n\njulia> (\"hello.\", [1,2], Dict(:a => \"one.\")) ⊕ (\"world.\", [3], Dict(:a => \"two.\"))\n(\"hello.world.\", [1, 2, 3], Dict(:a => \"one.two.\"))\n\njulia> neutral(Pair{String, Vector})\n\"\" => Any[]\n\njulia> neutral(Tuple{String, Vector})\n(\"\", Any[])\n\njulia> neutral(Tuple{String})\n(\"\",)","category":"page"},{"location":"manual-DataTypes/#FlipTypes-10","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"No implementation. Please see Writer instead.","category":"page"},{"location":"manual-DataTypes/#State","page":"DataTypes","title":"State","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"With the State monad you can hide the modification of some external variable. In Julia you can modify variables by side-effect, hence this State monad is rather for illustrative purposes only. However if you like to have tight control over your state or config, you can give it a try.","category":"page"},{"location":"manual-DataTypes/#Functor/Applicative/Monad-11","page":"DataTypes","title":"Functor/Applicative/Monad","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"You can lift an arbitrary value into a  State with TypeClasses.pure. It won't do anything with the state.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> run(pure(State, \"returnvalue\"), :initialstate)\n(\"returnvalue\", :initialstate)","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"If you want to change the state, use TypeClasses.putstate, and if you want to access the state itself, you can use TypeClasses.getstate. For the general case you can construct State by passing a function taking the state as its only input argument, and returning result value and new state in a tuple.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> putget = @syntax_flatmap begin\n         putstate(4)\n         x = getstate\n         State(s -> (\"x = $x\", s+1))\n       end;\n\njulia> value, state = putget(())\n(\"x = 4\", 5)","category":"page"},{"location":"manual-DataTypes/#Monoid/Alternative-11","page":"DataTypes","title":"Monoid/Alternative","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"State only supports combine by forwarding it to its inner element. The state is passed from the first to the second.","category":"page"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"julia> state1 = State(s -> (\"one.\", s*s));\n\njulia> state2 = State(s -> (\"two.\", 2s));\n\njulia> run(state1 ⊕ state2, 3)\n(\"one.two.\", 18)\n\njulia> run(state2 ⊕ state1, 3)\n(\"two.one.\", 36)","category":"page"},{"location":"manual-DataTypes/#FlipTypes-11","page":"DataTypes","title":"FlipTypes","text":"","category":"section"},{"location":"manual-DataTypes/","page":"DataTypes","title":"DataTypes","text":"There is no implementation for flip_types, as you would need to look inside the State and wrap it out. That is hidden behind a function which depends on the state, so no way to bring things inside-out without such a state.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TypeClasses\nDocTestSetup  = quote\n    using TypeClasses\nend","category":"page"},{"location":"#TypeClasses.jl","page":"Home","title":"TypeClasses.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TypeClasses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"TypeClasses defines general programmatic abstractions taken from Scala cats and Haskell TypeClasses.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The following interfaces are defined:","category":"page"},{"location":"","page":"Home","title":"Home","text":"TypeClass Methods Description\nFunctor  Base.map The basic definition of a container or computational context.\nApplicative Functor & TypeClasses.pure & TypeClasses.ap (automatically defined when map and flatmap are defined) Computational context with support for parallel execution.\nMonad Applicative & TypeClasses.flatmap Computational context with support for sequential, nested execution.\nSemigroup TypeClasses.combine, alias ⊕ The notion of something which can be combined with other things of its kind.\nMonoid Semigroup & TypeClasses.neutral A semigroup with a neutral element is called a Monoid, an often used category.\nAlternative TypeClasses.neutral & TypeClasses.orelse, alias ⊘ Slightly different than Monoid, the orelse semantic does not merge two values, but just takes one of the two.\nFlipTypes TypeClasses.flip_types Enables dealing with nested types. Transforms an A{B{C}} into an B{A{C}}.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience this packages further provides a couple of standard DataTypes and implements the interfaces for them.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"manual.md\", \"manual-TypeClasses.md\", \"manual-DataTypes.md\"]","category":"page"},{"location":"#main-index","page":"Home","title":"Library Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"library.md\"]","category":"page"}]
}
